# 内部类

## 10.1 创建内部类

典型的使用内部类的情况：外部类将有一个方法，该方法返回一个指向内部类的引用

如果想从外部类的费静态方法之外的任意位置创建某个内部类的对象，必须指明这个对象的类型：**OuterClassName.InnerClassName**

## 10.2 链接到外部类

内部类对象具有对其外围对象所有成员的访问权限，还能访问其外围类的所有成员。实现机理：内部类对象会秘密捕获一个指向那个外围类对象的引用。在你访问此外围类的成员时，就是用那个引用来选择外围类的成员

## 10.3 使用.this和.new

在内部类内获取外部类对象的引用用外部类名字加.this获得

创建新内部类对象需要外部类对象名加.new

```Java
DotNew dn = new DotNew();
DotNew.Inner dni = dn.new Inner();
```

也不用声明``dn.new DotNew.Inner``

没有外部类对象时不能创建内部类对象，因为内部类对象需要一个外部类对象的引用，嵌套类（静态内部类）除外。

## 10.4 内部类与向上转型

private内部类为类的设计者提供了一种途径，可以完全阻止任何依赖于类型的编码，并且完全隐藏实现的细节。

## 10.5 在方法和作用域内的内部类

在方法和作用域内定义的内部类，作用域不超过类或作用域

## 10.6 匿名内部类

如果定义一个匿名内部类，希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final。

匿名内部类与正规的继承相比有些受限，匿名内部类可以扩展类也可以实现接口，但是不能两者兼备。实现接口也只能一个。

## 10.7 嵌套类

不需要内部类对象和外部类对象之间有联系，可以将内部类声明为static，称为嵌套类。普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。当内部类为static时：

1. 要创建嵌套类的对象，并不需要其外围类的对象。
1. 不能从嵌套类的对象中访问非静态的外围类对象

普通的内部类不能含有static数据和static字段，也不能包含嵌套类，嵌套类可以包含这些东西。

嵌套类可以放在接口中，自动是public和static的。

创建某些公共代码，使它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。另外，用嵌套类也可以进行代码测试。

## 10.8 为什么需要内部类

内部类最吸引人的原因：每个内部类第一能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

关系到抽象的类或具体的类的多重继承，只能用内部类来实现。

内部类的一些其他特性：

1. 内部类可以由多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
1. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
1. 创建内部类对象的时刻并不依赖于外围类对象的创建。
1. 内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。

## 10.9 内部类的继承

由于内部类具有一个外部类的引用，所以继承内部类时必须初始化那个引用

```Java
class WithInner {
    class Inner {}
}

public class InheritInner extends WithInner.Inner {
    //! InheritInner(){} //won't compile
    InheritInner(WithInner wi) {
        wi.super();
    }
    public static void main(String[] args){
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    }
}
```

## 10.10 内部类可以被覆盖吗

继承了某个外围类，内部类并没有发生变化，两个内部类是完全独立的两个实体，各自在自己的命名空间内。明确地继承某个内部类才是真正的继承。

## 10.11 局部内部类

局部内部类的名字在方法外是看不到的，为什么我们仍使用局部内部类而不是匿名内部类？因为我们需要一个已命名的构造器，或者重载构造器，而匿名内部类只能用于初始化。

## 10.12 内部类标识符

外围类$内部类