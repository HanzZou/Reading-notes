# 通过异常处理错误

## 12.1 概念

## 12.2 基本异常

尽管返回的异常对象常与方法的返回类型不同，但是效果上相同，可以把异常看作是一种不同的返回机制

## 12.3 捕获异常

1. 终止模型：假设错误非常关键，程序无法返回到异常发生的地方继续执行
1. 恢复模型：希望异常被处理之后能继续执行程序，则遇到错误后不抛出异常，而是调用方法来修正错误，或是把try块放在while循环里

恢复模型并不实用，耦合性过高，恢复处理程序需要了解异常抛出地点，这增加了代码编写和维护的困难

## 12.4 创建自定义异常

继承自Exception的自定义异常类，调用super方法即Exception的构造方法，则在打印异常信息时会把这个字符串打印出来。

异常打印的默认版本`e.printStackTrace();`是将信息输出到标准错误流

## 12.5 异常说明

如果方法声明中包含异常说明，则表示该方法不会抛出任何的异常（除了从RuntimeException继承的异常，它们可以在没有说明的情况下被抛出）

## 12.6 捕获所有的异常

如果要写一个捕获所有异常的处理代码，最好放在处理程序列表的末尾，以防在其他处理程序发挥作用前把异常捕获了

`Throwable fillInStackTrace()`用于在Throwable对象的内部记录栈帧的当前状态，这在程序重新抛出错误或异常时很有用

`e.getStackTrace()`获得一个数组，就是方法的调用栈，0是栈顶元素，就是调用序列中最后一个方法

重新抛出异常：重新抛出异常时，使用`throw (Exception)e.fillInStackTrace();`，上一级捕获异常打印的调用栈会以抛出异常处为新的异常发生地。重新抛出新异常的效果相同。

Throwable子类在构造器中接受一个cause对象作为参数，来表示原始异常，这样通过把原始异常传递给新的异常，即时在当前位置创建并抛出了新的异常，也能通过异常链追踪到异常最初发生的位置。

## 12.7 Java标准异常

Throwable类有两个子类，Error和Exception

## 12.8 使用finally进行清理

finally可以确保在任何情形下清理工作都完成，在return中使用finally可以保证无论从哪个位置结束方法，都有一段代码能被执行到。

异常丢失：在try块中抛出异常，不写catch块，而在finally块中抛出另一个异常，上一级作用域会捕捉到到finally块中抛出的异常而忽略try块中抛出的异常。另外，在finally块中return也会丢失异常。我们的代码要把所有可能抛出异常部分放在try-catch子句里。

## 12.9 异常的限制

一个类既继承自一个基类，又实现了一个接口，基类与接口共同拥有同一个抛出不同异常的方法，则子类的该方法只能抛出继承方法的异常。

异常限制对于构造器不起作用，子类构造器抛出的异常不必理会基类构造器抛出的异常

派生类构造器不能捕获基类构造器抛出的异常

(Page270)

## 12.10 构造器

## 12.11 异常匹配

抛出异常在查找相对应的处理程序时并不要求同处理程序完全匹配，派生类对象也可以匹配其基类的处理程序

## 12.12 其他可选方式

## 12.14 异常使用指南

应该在下列情况下使用异常：

1. 在适当的级别处理问题（在知道该如何处理的情况下才捕获异常）
1. 解决问题并且重新调用产生异常的方法
1. 进行少许修补，然后绕过异常发生的地方继续执行
1. 用别的数据进行计算，以代替方法预计会返回的值
1. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层
1. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层
1. 终止程序
1. 进行简化
1. 让类库和程序更安全