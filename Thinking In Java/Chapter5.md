# 初始化与清理

## 5.1 用构造器确保初始化

构造器不返回任何值，虽然new表达式确实返回了新建对象的引用

## 5.2 方法重载

构造器是强制重载方法名的一个原因

以参数类型列表区分重载方法

基本类型能从一个“较小”的类型自动提升到一个“较大”的类型。如果传入的实际参数大于重载方法声明的形式参数，需要进行强制“窄化”转型，不然会报错。

## 5.3 默认构造器

如果类中没有构造器，编译器会提供一个默认构造器。如果已经定义了一个构造器，编译器就不会自动构建默认构造器，需要自己编写默认构造器。

## 5.4 this关键字

编译器会对对象的方法进行暗中改造，把“所操作对象的引用”作为第一个参数传递给方法。

```Java
void peel(int i) {...}

a.peel(1);
```

实际上变成

```Java
void peel(a,1);
```

假设在方法内部想要得到这个引用，使用this关键词，表示“调用方法的那个对象”的引用。

在构造器中调用另一个构造器，避免重复代码，此时就要用到this关键字。尽管this可以调用一个构造器，但是不能调用两个。

在非构造器方法中调用构造器方法是不被允许的。

static方法就是没有this的方法，方法体内不能使用对象的引用。所以在static方法内不能调用非static方法。

## 5.5 清理：终结处理和垃圾回收

Java允许在类中定义一个finalize()方法，一旦垃圾回收器准备好释放对象占用的存储空间，将率先调用finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

对象可能不被垃圾回收，垃圾回收并不等于“析构”，finalize()不能作为通用的清理方法

垃圾回收只与内存有关

之所以要使用finalize()方法，可能是因为在Java中使用了本地方法（在Java中调用非Java语言的方法），一般支持C和C++，所以也许会调用C的malloc()函数系列来分配内存，除非调用了free()方法，否则存储空间讲的不到释放。此时，在finalize()中调用free()方法。

当一个对象超出作用域时，finalize()并不会被调用

Java的堆空间分配类似于传送带，每分配一个对象，堆指针往前移动一格。另外，为避免频繁的页面调度，垃圾回收器会在回收空间时使堆中对象紧密排列，这样堆指针就能很容易移动到更靠近传送带开始的位置

引用计数是一种简单的垃圾回收机制，但在循环引用的情况下会出现问题，引用计数常用来说明垃圾回收的工作方式，但未被应用于任何一种任何一种Java虚拟机中

对任何活的对象，一定能够追溯到其存活在堆栈和静态存储区中的引用，因此遍历所有引用，必须追踪它所引用的对象，就能找到所有活的对象，对于每个引用，追踪它所引用的对象，然后是这个对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。

Java虚拟机使用一种自适应的垃圾回收技术，停止-复制（stop-copy）,暂停程序的运行，然后将存活的对象从当前堆复制到另一个堆，没有被复制的都是垃圾。被复制到新堆的对象都是紧凑排列的，就能轻松地安排空间。

一些虚拟机会针对停止-复制的缺点（资源浪费多）而进行改进，要是没有新垃圾产生，就转换为标记-清扫模式（mark-sweep），对所有引用进行遍历，对存活的对象进行标记，标记结束后把所有未被标记的对象进行清理，再重新整理剩下的对象，得到连续的空间。

## 5.6 成员初始化

尽量保证所有的变量都被初始化

如果一个类的成员变量大多是基本类型，可以选择不进行初始化，基本类型都有默认的初始值，对象引用的初始值为null

可以通过调用某个方法来提供初值，但是方法的参数必须是已经初始化了的

## 5.7 构造器初始化

自动初始化将在构造器初始化之前发生

## 5.8 数组初始化

```Java
int[] a;
```

只是获得了一个数组的引用，编译器并没有未数组对象本身分配任何存储空间。初始化表达式才能为数组创建相应的存储空间。

```Java
static void printArray(Object... args){...}
```

可变参数列表

在调用可变参数的方法时，要避免歧义

```Java
void f(float i, Character ... args){}
void f(Character ... args){}
```

会出现编译时错误CompileTimeError，可改为

```Java
void f(float i, Character ... args){}
void f(char i, Character ... args){}
```

总结：应只在重载方法的一个版本上使用可变参数列表，且避免与其他版本的歧义，或者不使用

## 5.9 枚举类型

