# 接口

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法

## 9.1 抽象类和抽象方法

有些类创建的目的就是为导出类创建一个通用接口，调用本身的方法往往会出现一些错误，可以将这些类称为抽象类

```Java
abstract void f();
```

被称为抽象方法，包含一个或多个此类方法的一定要被限定为抽象类

继承抽象类的导出类需要为所有抽象方法提供具体实现，不然这个导出类也会被强制用abstract来限制

抽象类也可以用来限定类不能产生对象

## 9.2 接口

可以在接口中显式讲方法声明为public的，但即使不那么做，它们也是public的。当要实现一个接口时，在接口中被定义的方法必须被定义为是public的。

## 9.3 完全解耦

策略模式和适配器模式的例子

## 9.4 Java中的多重继承

使用接口的核心原因：为了能够向上转型为多个基类型（以及由此而带来的灵活性）

如果要创建不带任何方法定义和成员变量的基类，那么应该选择接口而不是抽象类；如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口

## 9.5 通过继承来扩展接口

## 9.6 适配接口

策略模式，可研究Scanner类和Readable接口

## 9.7 接口中的域

放入接口中的任何域都自动是static和final的，所以接口就是一种很便捷用来创建常量组的工具。

以前版本的代码中经常有这种用法：将接口作为常量的载体，产生和enum枚举相同的效果，现在这种用法已经被枚举所取代

这些值被存储在接口的静态存储区域内

## 9.8 嵌套接口

接口嵌套在接口内不能为private，在类中的接口可以为private，并只能在该类中被实现

## 9.9 接口和工厂